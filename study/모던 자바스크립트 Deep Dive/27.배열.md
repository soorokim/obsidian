# 27. 배열

## 27.1 배열이란?

- 배열: 여러 값을 순차적으로 나열한 구조
  - 요소: 배열이 가지고 있는 값, 자바스크립트의 모든 값은 배열의 요소가 될 수 있다.
  - 인덱스: 요소의 위치를 가리키는 0이상의 정수, 0 부터 시작한다.
  - length: 배열의 길이를 나타내는 배열의 프로퍼티
- 배열 리터럴, Array 생성자 함수, Array.of / Array.from 메서드로 생성 할 수 있다.
- 배열은 객체 타입이다.
- 일반 객체와 구별되는 독특한 특징

| 구분      | 객체                      | 배열          |
| --------- | ------------------------- | ------------- |
| 구조      | 프로퍼티 키와 프로퍼티 값 | 인덱스와 요소 |
| 값의 참조 | 프로퍼티 키               | 인덱스        |
| 값의 순서 | X                         | O             |
| length    | X                         | O             |

## 27.2 자바스크립트 배열은 배열이 아니다.

- 자료구조<sup>data structure</sup>에서 말하는 배열
  - 밀집 배열: 동일한 크기의 메모리 공간이 빈틈없이 나열된 구조
  - 한번의 연산으로 임의의 요소에 접근(임의접근, 시간 복잡도 `O(1)`) 할 수 있다. 빠르다.
  - 정렬되지 않은 배열에서 특정 요소를 검색하는 경우 모든 배열의 요소를 처음부터 발견할 때까지 차례대로 검색(선형 검색, 시간복잡도 `O(n)`)
  - 배열에 요소를 삽입/삭제 하는경우 배열의 요소를 연속적으로 이동하기 위해 요소를 이동시켜야 하는 단점이 있다.
- 자바스크립트의 배열
  - 희소 배열: 배열의 요소가 연속적으로 이어져 있지 않은 배열
  - 각 요소를 위한 메모리 공간은 동일한 크기를 갖지 않아도 된다. 연속적으로 이어져 있지 않을 수 도 있다.
  - 일반적인 배열의 동작을 흉내 낸 특수한 객체다.
  - 해시 테이블로 구현된 객체이므로 요소에 접근하는 경우 일반적인 배열보다 성능적으로 느릴 수 밖에 없는 구조적 단점이 있다.
  - 특정 요소를 검색하거나 삽입/삭제 하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.
  - 모던 자바스크립트 엔진은 배열을 일반 객체와 구별하여 좀 더 배열처럼 동작하도록 최적화 하여 구현했다.(토끼굴)

## 27.3 length 프로퍼티와 희소 배열

- length 프로퍼티는 0 ~ 2<sup>32</sup>-1 미만의 양수, 최대 4,294,967,295개 가질 수 있다. (약 42억 개)

```ts
// 현재 length 보다 작은 값을 할당하면 배열의 길이가 줄어든다.
const arr = [1, 2, 3, 4];

arr.length = 3;

console.log(arr); // [1, 2, 3]

// 현재 length 보다 큰 값을 할당하면 length값은 변경되지만 실제로 배열의 길이가 늘어나지 않는다.
arr.length = 5;

console.log(arr); // [1, 2, 3, , ]

console.log(Object.getOwnPropertyDescriptors(arr));
/*
{
  0: { value: 1, writable: true, enumerable: true, configurable: true },
  1: { value: 2, writable: true, enumerable: true, configurable: true },
  2: { value: 3, writable: true, enumerable: true, configurable: true },
  length: { value: 5, writable: true, enumerable: false, configurable: false },
};
*/
```

- 희소배열을 사용하면 안되는 이유
  - 성능에 좋지 않은 영향을 준다.
    - 모던 자바스크립트 엔진은 요소의 타입이 일치하는 배열을 생성할 때 일반적인 의미의 배열처럼 연속된 메모리 공간을 확보하는 것으로 알려져 있다.
  - 의도적으로 희소 배열을 만들어야 하는 경우는 없다.
  - 연속적인 값의 집합이라는 배열의 기본적인 개념과 맞지 않다.(이런걸로는 설득하기 힘듬 ㅠ, 되는데요? 쓰라고 만든거 아닐까요? 저는 문제 없어요 ㅎㅎ)

## 27.4 배열 생성

### 27.4.1 배열 리터럴

```ts
const a = [];
```

### 27.4.2 Array 생성자 함수

- Array 생성자 함수는 전달된 인수의 개수에 따라 다르게 동작한다.

  - 0개: 빈배열
  - 1개: 전달 된 인수가 length값 인 array를 생성한다.(length만 있고 요소가 없는 희소 배열이다.)
  - 2개 이상 or 숫자가 아닌 경우: 인수를 요소로 갖는 배열을 생성한다

  ```ts
  new Array(1, 2, 3); // [1, 2, 3]
  ```

- 일반 함수로 호출해도 배열을 생성하는 생성자 함수로 호출한다. ([new.target을 확인한다.](<17.생성자 함수에 의한 객체 생성#17.2.7-new.target>))

### 27.4.3 Array.of

- 전달된 인수를 요소로 갖는 배열을 생성한다.

```ts
Array.of(1); // [1]
Array.of(1, 2, 3); // [1,2,3]
Array.of("string"); // ["string"]
```

### 27.4.4 Array.from

- 유사 배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환한다.
- 두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다.(아니 개꿀이자녀?)

```ts
// 알고리즘 풀 때 개꿀
Array.from({ length: 3 }, (_, i) => i); // [0, 1, 2]
```

## 27.5 배열 요소의 참조

- 다들 할 줄 알죠?
- 인덱스로 접근한다.
- 없는 인덱스는 undefined이다.

## 27.6 배열 요소의 추가와 갱신

- 배열에 요소 동적 추가 가능 존재하지 않는 인덱스를 사용하면 새로운 요소가 추가되고 length가 자동 갱신됨
- 정수 이외의 값을 인덱스로 사용하면 요소가 생성되는게 아니라 프로퍼티가 생성된다. (몰랐다! 근데 모를 수 밖에 없는게 하면 안된다.)

### 27.7 배열 요소의 삭제

- delete 연산자를 사용할 수 있다. (몰랐다! 영원히 모르자) 자바스크립트에서 자주 `사용할 수 있다`는 말은 `사용해도 된다`는 말은 아니다. 쓰지마라
- delete로 삭제해도 length는 변하지 않는다. 결과 적으로 희소배열이 된다.
- Array.prototype.slice 메서드를 사용하여 특정요소를 삭제하자

## 27.8 배열 메서드

- 원본 배열을 직접 변경하는 메서드, 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드가 있다.
- 사이드 이펙트를 줄이기 위해서는 데이터의 불변성을 지키는것이 유리하므로 원본 배열을 직접 변경하는 메서드는 잘 알아두고 조심해서 사용하거나 다른 방법을 사용하는것이 좋다.
- 가급적 원본 배열을 직접 변경하지 않는 메서드를 사용하자

### 27.8.1 Array.isArray

- 인수가 배열이면 true 아니라면 false를 반환한다.

### 27.8.2 Array.prototype.indexOf

- ~~인수로 전달한 요소와 중복되는 요소가 여러 개 있다면 첫번째 발견된 요소의 인덱스를 반환, 요소가 존재하지 않으면 -1을 반환~~
- includes를 사용하자

### 27.8.3 Array.prototype.push(🔴원본 배열 수정)

- push는 성능면에서 좋지 않다.(토끼굴) length 프로퍼티를 사용해 마지막에 요소를 직접 추가하는 것이 빠르다.
- push 보다는 스프레드 문법을 사용하는 편이 좋다.

```ts
let arr1 = [1, 2, 3, 4];
let arr2 = [1, 2, 3, 4];

const push = (origin: number[], input: number) => {
  return [...origin, input];
};

// 원본 배열 수정
const results1 = arr1.push(5);
console.log(results1); // 5 변경된 배열의 length를 반호
console.log(arr1); // [1, 2, 3, 4, 5] 원본 배열이 수정됨

// 원본 배열을 수정하지 않음
const results2 = push(arr2);
console.log(results2); // [1, 2, 3, 4, 5]
console.log(arr2); // [1, 2, 3, 4]
```

### 27.8.4 Array.prototype.pop(🔴원본 배열 수정)

- 맨 마지막 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다.
- pop과 push로 스택을 쉽게 구현 할 수 있다.

### 27.8.5 Array.prototype.unshift(🔴원본 배열 수정)

- 인수로 전달받은 모든 값을 배열 맨 앞에 추가하고 변경된 length 값을 반환한다.
- 원본 배열을 직접 수정하므로 스프레드 문법을 사용하자

```ts
let arr1 = [1, 2, 3, 4];
let arr2 = [1, 2, 3, 4];

const unshift = (origin: number[], input: number) => {
  return [input, ...origin];
};

// 원본 배열 수정
const results1 = arr1.unshift(0);
console.log(results1); // 5 변경된 배열의 length를 리턴한다.
console.log(arr1); // [0, 1, 2, 3, 4]

// 원본 배열을 수정하지 않음
const results2 = unshift(arr2, 0);
console.log(results2); // [0, 1, 2, 3, 4]
console.log(arr2); // [1, 2, 3, 4]
```

### 27.8.6 Array.prototype.shift(🔴원본 배열 수정)

- 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다.
- shift와 push를 사용하여 큐를 쉽게 구현 할 수 있다.

```ts
let arr1 = [1, 2, 3, 4];
let arr2 = [1, 2, 3, 4];

const shift = (origin: number[]) => {
  const [f, ...rest] = origin;
  return [f, rest];
};

// 원본 배열 수정
const results1 = arr1.shift();
console.log(results1); // 1
console.log(arr1); // [2, 3, 4]

// 원본 배열을 수정하지 않음
const [value, newArr] = shift(arr2);
console.log(value, newArr); // 1, [1, 2, 3, 4, 5]
console.log(arr2); // [1, 2, 3, 4]
```

### 27.8.7 Array.prototype.concat(✅ 새로운 배열 생성)

- concat 메서드는 인수로 전달된 값을 마지막 요소로 추가한 새로운 배열을 반환한다.
- push와 unshift를 대체 할 수 있다.

```ts
const push = (x: any[], y: any[]) => x.concat(y);
const unshift = (x: any[], y: any[]) => y.concat(x);

const arr1 = [1, 2];
const arr2 = [3, 4];

console.log(push(arr1, arr2)); // [1, 2, 3, 4]
console.log(unshift(arr1, arr2)); // [3, 4, 1, 2]
```

- 통일성을 위해 스프레드 문법으로 일관성있게 사용하자

```ts
const push = (origin: any[], input: any[]) => [...origin, ...input];
const unshift = (origin: any[], input: any[]) => [...input, ...origin];

const arr1 = [1, 2];
const arr2 = [3, 4];

console.log(push(arr1, arr2)); // [1, 2, 3, 4]
console.log(unshift(arr1, arr2)); // [3, 4, 1, 2]
```

### 27.8.8 Array.prototype.splice(🔴원본 배열 수정)

- splice는 3개의 매개변수가 있으며 원본 배열을 직접 변경한다.

```ts
/* 
  start: 제거하기 할 시작 인덱스, -n 이면 마지막에서 n번 째 요소를 가리킨다.
  deleteCount: 제거할 요소의 수, 0 또는 생략하면 아무것도 제거되지 않는다.
  items: 제거한 위치에 삽입할 목록, 생략하면 제거하기만 한다.
*/
splice(start, deleteCount, items);
```

- 배열의 특정요소를 제거하려면 indexOf로 메서드로 특정 요소의 인덱스를 취득하고 splice로 제거한다.
- filter 메서드를 사용할 수 있지만 filter는 특정요소와 같은 모든 중복 요소가 제거 된다.

### 27.8.9 Array.prototype.slice(✅새로운 배열 생성)

- slice 메서드는 인수로 전달된 범위의 요소들을 복사하여 새로운 배열로 반환한다.

```ts
/*
 start: 복사를 시작할 인덱스 -n이면 마지막에서 n번째 요소를 가리킨다. 생략하면 0이다.
 end: 복사를 종료할 인덱스이다. 생략 가능하며 기본값은 length 프로퍼티이다.
*/
slice(start, end);
```

- slice로 복사할때 얕은 복사를 한다. (주의)
- ~~slice가 복사본을 사용하는 것을 이용해 arguments, HTMLCollection, NodeList 같은 유사배열 객체를 배열로 변환 할 수있다.~~ Array.from 을 사용하는것이 다 간편하다.
- 이터러블 객체는 스프레드 문법을 사용하여 배열 변환이 가능하다.

### 27.8.10 Array.prototype.join(🔴✅)

### 27.8.11 Array.prototype.reverse(🔴✅)

### 27.8.12 Array.prototype.fill(🔴✅)

### 27.8.13 Array.prototype.includes(🔴✅)

### 27.8.14 Array.prototype.flat(🔴✅)

## 27.9 배열 고차함수

### 27.9.1 Array.prototype.sort(🔴)

### 27.9.2 Array.prototype.forEach(✅)

### 27.9.3 Array.prototype.map(✅)

### 27.9.4 Array.prototype.filter(✅)

### 27.9.5 Array.prototype.reduce(✅)

### 27.9.6 Array.prototype.some(✅)

### 27.9.7 Array.prototype.every(✅)

### 27.9.8 Array.prototype.find(✅)

### 27.9.9 Array.prototype.findIndex(✅)

### 27.9.10 Array.prototype.flatMap(✅)

## 추가 조사

- 아래 메서드들은 2023에 추가됐으므로 최신 브라우저가 아니면 [폴리필](https://github.com/zloirock/core-js#change-array-by-copy)이 필요함!

### Array.prototype.toReversed(✅)

### Array.prototype.toSorted(✅)

### Array.prototype.toSpliced(✅)
