# 25. 클래스

## 25.1 클래스는 프로토타입의 문법적 설탕인가?

- 클래스와 생성자함수는 프로토타입의 기반 인스턴스를 생성하지만 정확히 동일하게 동작하지 않는다
- 클래스는 생성자 함수보다 엄격하며 생성자 함수에서 제공하지 않는 기능도 제공한다
- 차이점:
  - 클래스는 new 연산잔자 없이 호출하면 에러가 발생한다.
  - 클레스는 상속을 지원하는 extends와 super키워드를 제공한다.
  - 클레스는 호이스팅이 발생하지 않는 것 처럼 동작한다. (let과 const 처럼 동작)
  - 클레스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 해제할 수 없다.
  - 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모든 프로퍼티 어트리뷰트 `[[Enumerable]]`값이 false 이므로 열거되지 않는다.
- 새로운 객체 생성 메커니즘으로 보는것이 합당하다.

## 25.2 클래스의 정의

- 클래스의 이름은 생성자 함수와 마찬가지로 **파스칼 케이스**를 사용하는것이 일반적
- 클래스는 표현식으로 정의할 수 있다. 클래스는 함수이며 일급객체이다.
- 클래스 몸체에 정의할 수 있는 메서드는 constructor, 프로토타입 메서드, 정적 메서드 세가지가 있다.

## 25.3 클래스 호이스팅

- let과 const와 같이 호이스팅 된다. = TDZ가 존재한다.
- 모든 선언문은 런타임이전에 실행되기 때문에 var, let, const, function, function\*, class 키워드로 선언된 모든 식별자는 호이스팅 된다.

## 25.4 인스턴스 생성

- 반드시 new 연산자와 함께 호출해야 한다.
- 클래스 표현식을 사용하는 경우 식별자를 사용해 인스턴스를 사용해야 한다.

## 25.5 메서드

### 25.5.1 constructor

- 인스턴스를 생성하고 초기화 하기 위한 특수 메서드다.
- 이름을 변경 할 수 없다.
- constructor 내부의 this는 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스를 가리킨다.
- constructor는 메서드가 아니라 클래스가 생성한 함수 객체 코드의 일부가 된다.
- 클래스의 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다.
- `클래스의 constructor 메서드` !== `프로토 타입 constructor 프로퍼티` (이름만 같다.)
- 최대 한개만 존재 할 수 있다.
- 생략하면 빈 constructor 함수가 암묵적으로 정의 된다.
  ```ts
  class Person {}
  // 아래와 같이 된다
  class Person {
    constructor() {}
  }
  ```
- 인스턴스를 초기화 하면서 프로퍼티를 추가하기 위해서는 constructor 내부에서 this에 프로퍼티를 추가해야 하므로 constructor를 생략해서는 안된다.
- constructor는 별도의 반환문을 갖지 않아야 하며 이는 생성자 함수에서 반환문을 갖지 않아야 하는 것과 같은 맥락이다.

### 25.5.2 프로토타입 메서드

- 클래스 몸체에서 정의한 메드는 기본적으로 프로토타입 메서드가 된다.
- 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.

### 25.5.3 정적 메서드

- 메서드에 static 키워드를 붙이면 정적 메서드가 된다.

### 25.5.4 정적 메서드와 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

- 클래스 또는 생성자 함수를 하나의 네임스페이스로 사용하여 정적 메서드를 모아놓으면 이름 충돌 가능성을 줄여 주고 관련 함수를 구조화 할수 있는 효과가 있다.

> ES6에 추가된 표준 빌트인 객체 Number의 정적 메서드
> Number의 정적 메서드 isFinite, isNaN, parseFloat, parseInt는 빌트인 전역 함수보다 엄격하다.

### 25.5.5 클래스에서 정의한 메서드의 특징

1. function 키워드를 생략한 메서드 축약 표현을 사용한다.
2. 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요없다.
3. 암묵적으로 strict mode로 실행된다.
4. `for ... in`문이나 Object.keys 메서드 등ㅇ으로 열거할 수 없다.
5. 내부 메서드 `[[Construct]]`를 갖지 않는 non-constructor다. new 연산자와 함께 호출할 수 없다.

## 25.6 클래스의 인스턴스 생성 과정

### 1. 인스턴스 생성과 this 바인딩

- new 연산자와 함깨 클래스를 호출하면 constructor의 내부 코드가 실행되기 앞서 빈 객체를 생성하는데 이것이 인스턴스이며 this에 바인딩 된다.
- 클래스가 생성한 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정된다.(설명좀)

### 2. 인스턴스 초기화

- this에 바인딩된 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 초기화 한다.
- constructor가 생략되었다면 이 과정도 생략

### 3. 인스턴스 반환

- 인스턴스가 바인딩된 this가 암묵적으로 반환

## 25.7 프로퍼티

### 25.7.1 인스턴스 프로퍼티

- 인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다. (지금은 몸체에서도 가능하다.)
- 인스턴스 프로퍼티는 기본적으로 public이다. (private 키워드 사용가능하다.)

### 25.7.2 접근자 프로퍼티

- 접근자 프로퍼티는 클래서에서도 사용 가능하다.
- 클래스의 접근자 프로퍼티는 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 된다.

### 25.7.3 클래스 필드 정의 제안

- 클래스 필드는 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어이다.
- 몸체에서 클래스 필드를 정의하는것이 가능해다.
- 함수는 일급 객체이므로 클래스 필드에 할당할 수 있지만 클래스 필드는 프로퍼티 메서드가 아닌 인스턴스 메서드가 되므로 클래스 필드에 함수를 할당하는 것은 권장하지 않는다. (바로 이해가 되지 않는데 메모리관련 이슈인가요? 매 인스턴스 마다 함수를 새로 만들어서?)
- 클래스 필드에 화살표 함수를 할당하여 함수 내부의 this가 인스턴스를 가리키게 하는 경우도 있다. 메모리 손해를 감수해야 한다.

### 25.7.4 private 필드 정의 제안

- private 필드를 정의할 수 있다.
- private 필드는 클래스 내부에서만 접근 가능하고 자식 클래스 내부, 클래스 인스턴스를 통한 접근은 불가능하다.
- 접근자 프로퍼티를 통해 접근하는 것은 유효하다.
- private 필드는 반드시 클래스 몸체에 정의해야 한다. constructor에 직접 정의하면 에러가 발생한다.

### 25.7.5 static 필드 정의 제안

- static public필드, static private필드, static private 메서드를 정의할 수 있다.

## 25.8 상속에 의한 클래스 확장

### 25.8.1 클래스 상속과 생성자 함수 상속

- 상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는것이다.
- 코드 재사용 관점에서 매우 유용하다.
- extends 키워드가 기본 제공된다.
- 클래스가 없을때는 '의사 클래스 상속' 이라는 패턴을 사용해서클래스 확장을 흉내내기도 했다.

### 25.8.2 extends 키워드

- 상속을 통해 확장된 클래스를 서브 클래스, 자식 클래스, 파생 클래스라 한다.
- 서브 클래스에 상속된 클래스를 수퍼클래스, 베이스 클래스, 부모클래스 라고 부른다.
- 수퍼클래스와 서브클래스는 인스턴스의 프로토타입 체인뿐 아니라 클래스간의 프로토타입 체인도 생성한다.
- 프로토타입 메서드, 정적 메서드 모두 상속이 가능하다.

### 25.8.3 동적 상속

- extends 키워드는 클래스 뿐 아니라 생성자 함수를 상속 받아 클래스를 확장 할 수 있다. 하지만 extends는 클래스 뒤에 와야 한다.
- extends 키워드 다음에는 `[[Construct]]` 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용 할 수 있다.

```js
class Derived extends (condition ? Bass1 : Bass2) {}
```

### 25.8.4 서브클래스의 constructor

- 서브클래스에서 constructor를 생략하면 다음과 같이 된다.

```js
constructor(...args) { super(...args) }
```

- super()는 수퍼클래스의 constructor를 호출하여 인스턴스를 생성한다.

### 25.8.5 super 키워드

#### super 호출

- super를 호출하면 수퍼클래스의 constructor를 호출한다.
  1. 서브 클래스에서 constructor를 생략하지 않는 경우 서브클래스의 constructor에서는 반드시 super를 호출 해야한다.
  2. 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.
  3. super는 반드시 서브클래스의 constructor에서만 호출한다.

#### super 참조

- 메서드 내에서 super를 참조하면 수퍼클래스의 메서드를 호출할 수 있따.

  1.  서브클래스의 프로토타입 메서드 내에서 super.sayHi는 스퍼클래스의 프로토타입 메서드 sayHi를 가리킨다.

      - super를 참조하기 위해서는 super를 참조하는 메서드가 객체의 프로토타입을 찾을수 있도록 내부 슬롯 `[[HomeObject]]`를 가져야 한다.
      - ES6 메서드의 축약표현으로 정의된 함수만이 `[[HomeObject]]`를 갖는다.
      - super는 수퍼클래스의 메서드를 참조하기 위해 사용하므로 서브클래스의 메서드에서 사용행 ㅑ한다.
      - 객체 리터럴에서도 super 참조가 가능하다. 메서드 축약표현으로 정의된 함수만 가능

  2.  서브클래스의 정적 메서드 내에서 super.sayHi는 수퍼클래스의 정적메서드 sayHi를 가리킨다.

### 25.8.6 상속 클래스의 인스턴스 생성 과정

#### 1. 서브클래스의 super호출

- 자바스크립트 엔진은 클래스를 평가할 때 수퍼클래스와 서브클래스를 구분하기 위해 `[[ConstructorKind]]` 내부슬롯을 갖는다.
- `[[ConstructorKind]]` 는 수퍼클래스는 'base' 서브클래스는 'derived'로 설정된다.
- 서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다.

#### 2. 수퍼클래스의 인스턴스 생성과 this 바인딩

- 수퍼클래스의 constructor 내부 코드가 실행되기 전에 암묵적으로 빈객체를 생성한다.
- 수퍼클레스의 constructor 내부에서 new.target은 서브클래스를 가리키고 서브클래스가 생성한 인스턴스로 처리된다.
- 인스턴스의 프로토타입은 서브클래스의 prototype 프로퍼티가 된다.

#### 3. 수퍼클래스의 인스턴스 초기화

- 수퍼클래스의 constructor가 실행되어 this에 바인딩 되어있는 인스턴스를 초기화 한다.

#### 4. 서브클래스의 constructor로 복귀와 this 바인딩

- super가 반환한 인스턴스가 this에 바인딩 되고 서브클래스는 별도 인스턴스 생성을 하지 않는다.
- super가 호출되지 않으면 인스턴스가 생성되지 않고 this또한 참조 할 수 없다.

#### 5. 서브클래스의 인스턴스 초기화

- this에 바인딩 되어있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 값으로 프로퍼티를 초기화 한다.

#### 6. 인스턴스 반환

- 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.

### 25.8.7 표준 빌트인 생성자 함수 확장

- Symbol.species를 사용하여 정적 접근자 프로퍼티를 추가하여 메서드의 반환되는 인스턴스를 변경할 수 있다.

```js
class NewArray extends Array {
  static get [Symbol.species]() {
    return Array;
  }

  uniq() {
    return this.filter((v, i, self) => self.indexOf(v) === i);
  }

  average() {
    return this.reduce((prev, cur) => prev + cur, 0) / this.length;
  }
}

const myArr = new NewArray(1, 1, 2, 3);

const a = myArr.filter((v) => v % 2).uniq(); // myArr.filter(...).uniq is not a function !
```
