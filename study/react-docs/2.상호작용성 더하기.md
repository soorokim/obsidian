# 2. 상호작용성 더하기

## 2.1. 이벤트에 응답하기

### 2.1.1. 이벤트 핸들러 추가하기

이벤트 핸들러의 특징

- 주로 컴포넌트 내부에서 정의됩니다.
- `handle`로 시작하고 그 뒤에 이벤트명을 붙인 함수명을 가집니다.

> **주의하세요!**
> 이벤트 핸들러로 전달한 함수들은 호출이 아닌 전달되어야 합니다.
>
> 올바른 예시 `<button onClick={handleClick}>`
> 잘못된 예시 `<button onClick={handleClick()}>`
>
> 올바른 예시 `<button onClick={()=>alert('hi')}>`
> 잘못된 예시 `<button onClick={alert('hi')}>`

### 2.1.2. 이벤트 핸들러 내에서 Props 읽기

### 2.1.3. 이벤트 핸들러를 Props로 전달하기

### 2.1.3. 이벤트 핸들러 Props 명명하기

> **중요합니다!**
> 이벤트 핸들러에 적절한 HTML 태그를 사용하고 있는지 확인하세요. 예를 들어 클릭을 핸들링 하기 위해서 `div` 태그를 사용하는 것보다 `button` 태그를 사용하세요. 버튼의 스타일링이 싫어서 다른 UI 요소 처럼 보이도록 하고 싶다면 CSS를 통해서 목적을 이룰 수 있습니다.

### 2.1.4. 이벤트 전파

이벤트가 부모 자식간에 중첩되어 있는 경우 자식의 이벤트를 실행 시켜도 부모의 이벤트도 실행됩니다.

- 부여된 JSX 태그 내에서만 실행되는 `onScroll`을 제외한 React 내의 모든 이벤트는 전파됩니다.

### 2.1.5. 전파 멈추기

이벤트 핸들러는 이벤트 오브젝트를 유일한 매개변수로 받습니다.
이벤트의 정보를 읽어 들이는데 사용할 수 있습니다.
이벤트 오브젝트는 `stopPropagation`메서드로 전파를 멈출 수 있게 해줍니다.

```tsx
function Button({ onClick, children }) {
  return (
    <button
      onClick={(e) => {
        e.stopPropagation();
        onClick();
      }}
    >
      {children}
    </button>
  );
}
```

> **단계별 이벤트 캡쳐**
> 드물게 전파가 중단된 상황일지라도 자식 컴포넌트의 모든 이벤트를 캡처해 확인해야 할 수 있습니다. 일례로 분석을 위해 전파 로직에 상관 없이 모든 클릭 이벤트를 기록 하고 싶을 수 있습니다. 이를 위해 이벤트명 마지막에 `Capture`를 추가 하면 됩니다.

```tsx
function CaptureTestComponent() {
  return (
    <div
      onClickCapture={() => {
        /* this runs first */
      }}
    >
      <button onClick={(e) => e.stopPropagation()} />
      <button onClick={(e) => e.stopPropagation()} />
    </div>
  );
}
```

> 1. 아래로 전달 되면서 만나는 모든 `onClickCapture` 핸들러를 호출합니다.
> 2. 클릭된 요소의 `onClick` 핸들러를 실행 합니다.
> 3. 위로 전달되면서 만나는 모든 `onClick` 핸들러를 호출합니다.
>
> 이벤트 캡처는 라우터나 분석을 위한 코드에 유용할 수 있지만 일반 애플리케이션 코드에서는 사용하지 않을 가능성이 높습니다.

### 2.1.6. 전파의 대안으로 핸들러를 전달하기

### 2.1.7. 기본 동작 방지하기

이벤트 오브젝트의 `preventDefault`를 사용하여 기본 동작을 방지할 수 있습니다.

```tsx
export default function Signup() {
  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        alert("Submitting!");
      }}
    >
      <input />
      <button>Send</button>
    </form>
  );
}
```

### 2.1.8. 이벤트 핸들러가 사이드 이펙트를 가질 수도 있나요?

이벤트 핸들러는 순수할 피룡가 없기에 무언가를 변경하는데 최적의 위치입니다.

## 2.2. State: 컴포넌트의 기억장소

- 컴포넌트가 렌더링 간에 어떤 정보를 "기억"해야 할 때 state 변수를 사용합니다.

### 2.2.1. 일반 변수로 충분하지 않은 경우

1. 지역 변수는 렌더링 간에 유지되지 않습니다.
2. 지역 변수를 변경해도 렌더링을 일으키지 않습니다.

### 2.2.2. state 변수 추가하기

### 2.2.3. 첫 번째 훅 만나기

- `use`로 시작하는 다른 모든 함수를 훅이라고 합니다.
- 리엑트가 렌더링 중일 때만 사용할 수 있는 특별한 함수입니다.
  > **훅(use로 시작하는 함수)은 컴포넌트 최상위 수준 또는 커스텀 훅에서만 호출할 수 있습니다.**
  > 조건문, 반복문 또는 중첩 함수 내부에서는 훅을 호출할 수 없습니다.

### 2.2.4. `useState` 해부하기

- `const [something, setSomething]`과 같이 지정하는 것이 규칙입니다.
- `useState`의 유일한 인수는 state 변수의 초기값입니다.
- useState는 저장한 값을 가진 state변수, 변수를 업데이트하고 리렌더링을 유발하는 state setter 함수

### 2.2.5. 컴포넌트에 여러 state 변수 지정하기

- 서로 연관이 없는 경우 여러개의 state 변수를 가지는 것이 좋습니다. 하지만 두 변수를 자주 함께 변경하는 경우에는 두 변수를 하나로 합치는 것이 더 좋을 수 있습니다.
- 훅은 항상 같은 순서로 호출되기 때문에 실제로 잘 작동합니다. 또한 렌더링 전에 0으로 설정된 현재 인덱스 쌍을 유지 합니다. useState를 다음 state 쌍을 제공하고 인덱스를 증가시킵니다. ([나중에 다시 보기](https://ko.react.dev/learn/state-a-components-memory#how-does-react-know-which-state-to-return))

### 2.2.6. State는 격리되고 비공개로 유지됩니다

- State는 화면에 컴포넌트 인스턴스에 지역적입니다. 동일한 컴포넌트를 두 번 렌더링 한다면 각 복사본은 완전히 격리된 state를 가집니다.
- state는 선언한 컴포넌트에 완전히 비공개입니다. 부모 컴포넌트는 이를 변경할 수 없습니다.
- 두 번 렌더링 된 컴포넌트의 state를 동기화 하기 원한다면 자식 컴포넌트의 state를 제거하고 가까운 공유 부모 컴포넌트에 추가하면됩니다.

## 2.3. 렌더링 그리고 커밋

1. 렌더링 트리거
2. 컴포넌트 렌더링
3. DOM에 커밋

### 2.3.1. 1단계 렌더링 트리거

- 컴포넌트 렌더링이 일어나는 두 가지 이유
  - 컴포넌트의 초기 렌더링인 경우
  - 컴포넌트의 state가 업데이트된 경우

#### 초기 랜더링

#### State 업데이트 시 랜더링

- set 함수를 사용해서 상태를 업데이트하여 추가 렌더링을 트리거할 수 있습니다.

### 2.3.2. 2단계: React 컴포넌트 렌더링

- "렌더링"은 React에서 컴포넌트를 호출하는 것입니다.
- **초기 렌더링에서** React는 루트 컴포넌트를 호출합니다.
- **이후 렌더링에서** React는 state 업데이트가 일어나 렌더링을 트리거한 컴포넌트를 호출합니다.
- **초기 렌더링 하는 동안** DOM 노드를 생성합니다.
- **리렌더링 하는 동안** React 렌더링 이후 변경된 속성을 계산합니다. 다음 단계인 커밋 단계까지는 해당 정보로 아무런 작업도 수행하지 않습니다.
  > **렌더링은 항상 순수한 계산**
  >
  > - 동일한 입력에는 동일한 출력을 해야합니다. 동일한 입력에는 항상 동일한 JSX를 반환 해야 합니다.
  > - 이전의 state를 변경해서는 안됩니다. 렌더링 전에 존재했던 객체나 변수를 변경해서는 안 됩니다.

> Optimizing perfomance
> 업데이트된 컴포넌트 내에 중첩된 모든 컴포넌트를 렌더링하는 기본 동작은 업데이트된 컴포넌트가 트리에서 매우 높은 곳에 있는 경우 성능 최적화되지 않습니다. 성능 문제가 발생한는 경우 성능 섹션에 설명된 몇 가지 옵트인 방식으로 문제를 해결 할 수 있습니다. 하지만 **언제나 성급하게 최적화 하지마세요!** 최적화 전에 진짜 문제가 있는지 **측정이 우선**되어야 합니다!

### 2.3.3. 3단계: React가 DOM에 변경사항을 커밋

컴포넌트를 렌더링(호출)한 후 React는 DOM을 수정합니다.

- 초기 랜더링의 경우 React는 `appendChild()`DOM API를 사용하여 생성한 모든 DOM 노드를 화면에 표시합니다.
- 리렌더의 경우 React는 필요한 최소한의 작업(렌더링하는 동안 계산된 것!)을 적용하여 DOM이 최신 렌더링 출력과 일치하도록 합니다.
  React는 렌더링 간에 차이가 있는 경우에만 DOM 노드를 변경합니다.
- 렌더링 결과가 이전과 같으면 React는 DOM을 건드리지 않습니다.

### 2.3.4. 에필로그: 브라우저 페인트

렌더링이 완료되고 React가 DOM을 업데이트한 후 브라우저는 화면을 다시 그립니다. 이를 "브라우저 렌더링"이라고 하지만 이 문서의 나머지 부분에서 혼동을 피하고자 "페인팅"이라고 부를 것 입니다.

## 2.4. 스냅샷으로서의 state

### 2.4.1. state를 설정하면 렌더링이 동작합니다

인터페이스가 이벤트에 반응하려면 state를 업데이트해야 합니다.
setState로 state를 변경하면 아래와 같은 일이 발생합니다.

- setState가 state를 변경하고 새로운 렌더링을 큐에 넣습니다.
- React는 새로운 state값에 따라 컴포넌트를 다시 렌더링 합니다.

### 2.4.2. 렌더링은 그 시점에 스냅샷을 찍습니다

렌더링이란 React가 컴포넌트, 즉 함수를 호출한다는 뜻입니다. 해다 함수에서 반환하는 JSX는 시간상 UI의 스냅샷과 같습니다. props, 이벤트 핸들러, 로컬변수는 모두 렌더링 당시의 state를 사용해 계산됩니다.

React가 컴포넌트를 다시 렌더링할 때.

1. React가 함수를 다시 호출합니다.
2. 함수가 새로운 JSX 스냅샷을 반환합니다.
3. 그러면 React가 함수가 반환한 스냅샷과 일치하도록 화면을 업데이트 합니다.

컴포넌트는 해당 렌더링의 state 값을 사용해 계산된 새로운 props 세트와 이벤트 핸들러가 포함된 UI의 스냅샷을 JSX에 반환합니다.

- state를 설정하면 다음 렌더링에 대해서만 변경됩니다.
- state값은 이벤트 핸들러의 코드가 비동기적이더라도 렌더링 내에서 절대 변하지 않습니다.
