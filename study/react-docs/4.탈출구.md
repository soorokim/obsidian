# 탈출구

## Ref로 값 참조하기

- 컴포넌트가 일부 정보를 "기억"하고 싶지만 해당정보가 렌더링을 유발하지 않도록 하려면 ref를 사용하세요

### 컴포넌트에 ref를 추가하기

- ref.current 프로퍼티를 통해 해당 ref의 current 값에 접근할 수 있습니다.
- ref는 state처럼 문자열, 객체, 함수 등 모든것을 가리킬 수 있습니다.
- state와는 달리 읽고 수정할 수 있는 current 프로퍼티를 가진 일반 자바스크립트 객체입니다.
- ref를 수정해도 다시 렌더링 되지 않습니다.

### ref와 state의 차이

| refs                                                 | state                                                                 |
| ---------------------------------------------------- | --------------------------------------------------------------------- |
| state를 바꿔도 리렌더 되지 않습니다.                              | state를 바꾸면 리렌더 됩니다.                                                   |
| Mutable - 렌더링 프로세스 외부에서 current값을 수정 및 업데이트할 수 있습니다. | Immutable - state를 수정하기 위해서 setState 함수를 반드시 사용하여 리렌더 대기열에 넣어야 합니다.   |
| 랜더링 중에는 current 값을 읽거나 쓰면 안 됩니다.                     | 언제든지 state를 읽을 수 있습니다. 그러나 각 렌더마다 변경되지 않는 자체적인 state의 snapshot이 있습니다. |

### ref를 사용할 . 시기

- timeout IDs를 저장
- DOM 엘리먼트 저장 및 조작
- JSX를 계산하는 데 필요하지 않은 다른 객체 저장

### refs의 좋은 예시

- refs를 escape hatch로 간주합니다. Refs는 외부 시스템이나 브라우저 API로 작업할 때 유용합니다(???)
- 랜더링 중에 ref.current를 읽거나 쓰지마세요 렌더링 중에 일부 정보가 필요한 경우 state를 대신 사용하세요
- ref는 동기적으로 업데이트 됩니다. ref.current의 값을 변경하는 즉시 변경됩니다.
- ref가 일반 자바스크립트 객체 처럼 동작합니다

### refs와 DOM

- ref의 가장 일반적인 사례는 DOM엘리먼트에 엑세스 하는것입니다.

## Ref로 DOM 조작하기

### ref로 노드 가져오기

```tsx
import { useRef } from "react";

const Component = () => {
  const myRef = useRef(null);
  return <div ref={myRef} />;
};
```

- 이 DOM노드의 이벤트 헨들러에 접근하거나 노드에 정의된 내장 브라우저 API를 사용할 수 있습니다.

> ref 콜백을 사용하여 ref 리스트 관리하기
>
> ```tsx
> <ul>
>   {items.map((item) => {
>     // 작동하지 않습니다!
>     const ref = useRef(null);
>     return <li ref={ref} />;
>   })}
> </ul>
> ```
>
> ```tsx
> import { useRef } from "react";
>
> export default function CatFriends() {
>   const itemsRef = useRef(null);
>
>   function scrollToId(itemId) {
>     const map = getMap();
>     const node = map.get(itemId);
>     node.scrollIntoView({
>       behavior: "smooth",
>       block: "nearest",
>       inline: "center",
>     });
>   }
>
>   function getMap() {
>     if (!itemsRef.current) {
>       // 처음 사용하는 경우, Map을 초기화합니다.
>       itemsRef.current = new Map();
>     }
>     return itemsRef.current;
>   }
>
>   return (
>     <>
>       <nav>
>         <button onClick={() => scrollToId(0)}>Tom</button>
>         <button onClick={() => scrollToId(5)}>Maru</button>
>         <button onClick={() => scrollToId(9)}>Jellylorum</button>
>       </nav>
>       <div>
>         <ul>
>           {catList.map((cat) => (
>             <li
>               key={cat.id}
>               ref={(node) => {
>                 const map = getMap();
>                 if (node) {
>                   map.set(cat.id, node);
>                 } else {
>                   map.delete(cat.id);
>                 }
>               }}
>             >
>               <img src={cat.imageUrl} alt={"Cat #" + cat.id} />
>             </li>
>           ))}
>         </ul>
>       </div>
>     </>
>   );
> }
>
> const catList = [];
> for (let i = 0; i < 10; i++) {
>   catList.push({
>     id: i,
>     imageUrl: "https://placekitten.com/250/200?image=" + i,
>   });
> }
> ```

### 다른 컴포넌트의 DOM 노드 접근하기

- HTML 기본 요소(input 같은)인 내장 컴포넌트에 ref를 주입할 때 React는 ref의 current 프로퍼티를 그에 해당하는 DOM 노드로 설정한다.
- 직접 만든 컴포넌트에 ref를 주입할때는 기본적으로 null이 주어집니다. 직접 만든 컴포넌트를 ref.current에 설정하기 위해서는 forwardRef()를 사용해주어야 한다.

```tsx
const MyInput = forwardRef((props, ref)=>{
    return <input {...props} ref={ref}>
})
```

- 위 예시처럼 forwardRef로 감싸진 컴포넌트는 ref를 주입받아 전달할수 있게 된다.

> 명령형 처리방식으로 하위 API 노출하기
>
> `useImperativeHandle`을 사용하여 상위 노드에서 ref를 통해 사용할 수 있는 메서드를 제한하거나 커스텀 할 수 있다.
>
> ```tsx
> import { forwardRef, useRef, useImperativeHandle } from "react";
>
> const MyInput = forwardRef((props, ref) => {
>   const realInputRef = useRef(null);
>   useImperativeHandle(ref, () => ({
>     // 오직 focus만 노출합니다.
>     focus() {
>       realInputRef.current.focus();
>     },
>   }));
>   return <input {...props} ref={realInputRef} />;
> });
>
> export default function Form() {
>   const inputRef = useRef(null);
>
>   function handleClick() {
>     inputRef.current.focus();
>   }
>
>   return (
>     <>
>       <MyInput ref={inputRef} />
>       <button onClick={handleClick}>Focus the input</button>
>     </>
>   );
> }
> ```

## React가 ref를 부여할 때

- 렌더링 단계에서 React는 화면에 무엇을 그려야 하는지 알아내도록 컴포넌트를 호출합니다.
  - 일반적으로 렌더링하는 중 ref에 접근하는 것을 원하지 않습니다.
  - 첫 렌더링에서 DOM노드는 아직 생성되지 않아 ref.current는 null인 상태입니다.
  - 갱신에 의한 렌더링에서 DOM노드는 아직 업데이트 되지 않은 상태입니다.
  - 두 상황 모두 ref를 읽기에 너무 이른 상황입니다.
- 커밋 단계에서 React는 변경사항을 DOM에 적용합니다.
  - ref.current를 커밋 단계에서 설정합니다.
  - DOM을 변경하기 전에 React는 관련된 ref.current 값을 미리 null로 설정하고 DOM을 변경하는 즉시 대응하는 DOM 노드로 설정합니다.
- 대부분의 ref 접근은 이벤트 핸들러 안에서 일어납니다.

> flushSync로 state 변경을 동적으로 플러시하기
>
> 아래와 같이 setState를 flushSync로 감싸면 setState가 동기적으로 수행된다.
>
> ```ts
> flushSync(() => {
>   setState(555);
> });
> ```

### ref로 DOM을 조작하는 모범 사례

- 많은 경우 ref는 포커싱, 스크롤링, DOM 요소 크기 혹은 위치 측정 등 비 파괴적인 행동을 위해 사용됩니다.
- React가 관리하는 DOM 노드를 직접 바꾸려 하지 마세요.
- React가 관리하는 DOM 노드를 수정하려 한다면, React가 변경할 이유가 없는 부분만 수정하세요.

## Effect로 동기화 하기

### Effect란 무엇이고 이벤트와는 어떻게 다른가요?

- 컴포넌트 내부의 2가지 로직 유형
  - 렌더링 코드: 컴포넌트 최상단에 위치하며 props와 state를 적절히 변형해 결과적으로 JSX를 반환합니다. 렌더링 코드 로직은 순수해야합니다.
  - 이벤트 핸들러: 단순한 계산 용도가 아닌 무언가를 하는 컴포넌트 내부의 중첩함수 입니다. 입력필드를 업데이트 하거나 HTTP 요청을 보내거나 사용자를 다른 화면으로 이동시킬 수 있습니다. 사용자 작업으로 인해 발생하는 부수효과를 포함합니다.
- Effect는 렌더링 자체에 의해 발생하는 부수효과를 특정하는 것으로, 렌더링에 의해 직접 발생합니다.
- Effect는 어떤 상호작용과도 상관없이 발생하는 것입니다.
- Effect는 커밋이 끝난 후에 화면 업데이트가 이루어지고 나서 실행됩니다. 이 시점이 React컴포넌트를 외부 시스템과 동기화 하기 좋은 타이밍입니다.

### Effect가 필요 없을지도 모릅니다

- 컴포넌트에 Effect를 무작정 추가하지 마세요
- Effect는 React코드를 벗어난 특정 외부 시스템과 동기화 하기 위해 사용됩니다.(브라우저 API, 써드파티 위젯, 네트워크 등)

### Effect를 작성하는 법

- Effect를 작성하기 위해서는 다음 세 단계를 따름
  1. Effect 선언
     - 기본적으로 Effect는 모든 렌더링 후에 실행됩니다.
  2. Effect 의존성 지정
     - 대부분의 Effect는 모든 렌더링 후가 아닌 필요할 때만 다시 실행되어야 합니다. 의존성을 지정하여 이를 제어하는 방법을 배웁니다.
  3. 필요한 경우 클린업 함수 추가
     - 일부 Effect는 수행 중이던 작업을 중지, 취소 또는 정리하는 방법을 지정해야 할 수 있습니다. 이런경우 클린업 함수를 반환하여 어떻게 사용하는지 배웁니다.

#### 1단계: Effect 선언하기

- 컴포넌트가 렌더링 될 때마다 React는 화면을 업데이트한 다음 useEffect 내부의 코드를 실행합니다.
- useEffect는 화면에 렌더링이 반영될 때까지 코드 실행을 지연 시킵니다.
- 렌더링 중 접근할 수 없는 값(ex. ref)에 접근해야 하는 로직을 렌더링 연산에서 분리하기 위해 useEffect로 감쌉니다.
- 외부 시스템에 접근하는 경우(미디어 API) 또는 레거시 코드(jQuery 플러그인)를 사용하는 경우 useEffect를 활용합니다.

#### 2단계: Effect의 의존성 지정하기

- 기본적으로 Effect는 모든 렌더링 후에 실행됩니다. 이는 원하는 동작이 아닐 수 있습니다.
- 때때로 느릴수 있습니다. 실행을 건너뛰고 싶을 수 있습니다.
- 때때로 잘못될 수 있습니다. 컴포넌트가 처음 나타날때만 한번 실행하고 싶을 수 있습니다.
- useEffect의 두 번째 인자로 의존성 배열을 지정하여 불필요한 실행을 막을 수 있습니다.
- 지정한 모든 종속성이 이전 렌더링의 그것과 동일한 값을 가진 경우에만 Effect를 다시 실행하지 않습니다.
- React는 Object.is 비교를 사용하여 종속성 값을 비교합니다.
- **의존성을 선택 할 수 없다는 점에 유의 하세요**, Effect내부 코드를 기반으로 React가 기대하는 것과 일치하지 않으면 린트 에러가 발생합니다. 이를 통해 코드내의 많은 버그를 잡을 수 있습니다.
- 종속성에 추가를 원하지 않는 경우 **Effect 내부 코드를 수정하여 종속성이 필요하지 않도록 만드세요**
- 의존성 배열이 비어 있다면 마운트 될때만 실행됩니다.

#### 3단계: 필요하다면 클린업을 추가하세요

- 클린업 함수는 Effect가 다시 실행되기 전마다 그리고 컴포넌트가 언마운트 될때도 마지막으로 호출합니다.
- 개발모드에서는 컴포넌트를 다시 마운트 함으로써 React는 사용자가 다른 부분을 탐색하고 다시 돌아와도 코드가 깨지지 않을 것임을 확인합니다.
- 클린업 함수를 잘 구현하면 Effect를 한번 실행하는 것과 실행, 클린업, 이후 다시실행 하는 것 사이에 사용자에게 보이는 차이가 없어야 합니다.
- 배포환경에서는 한번만 실행합니다.

### 개발중에 Effect가 두 번 실행되는 경우를 다루는 방법

#### React로 작성되지 않은 위젯 제어하기

- 일부 API는 연속해서 두 번 호출하는 것을 허용하지 않을 수도 있습니다.

```tsx
useEffect(() => {
  // <dialog> 요소의 showModal 메서드는 두 번 호출하면 예외를 던집니다.
  // 클린업 함수를 구현하고 이 함수에서 대화 상자를 닫도록 만들어보세요.
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

#### 이벤트 구독하기

```ts
// 만약 Effect가 어떤 것을 구독한다면, 클린업 함수에서 구독을 해지해야 합니다.
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener("scroll", handleScroll);
  return () => window.removeEventListener("scroll", handleScroll);
}, []);
```

#### 애니메이션 트리거

```ts
// Effect가 어떤 요소를 애니메이션으로 표시하는 경우, 클린업 함수에서 애니메이션을 초기 값으로 재설정해야 합니다.
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  return () => {
    node.style.opacity = 0; // Reset to the initial value
  };
}, []);
```

#### 데이터 페칭

```ts
// 만약 Effect가 어떤 데이터를 가져온다면, 클린업 함수에서는 fetch를 중단하거나 결과를 무시해야 합니다.
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

> Effect에서 데이터를 가져오는 좋은 대안은 무엇인가요?
>
> Effect 안에서 fetch 호출을 작성하는 것은 데이터를 가져오는 인기있는 방법이지만 단점이 있습니다.
>
> - Effect는 서버에서 실행되지 않습니다.
> - Effect 안에서 직접 가져오면 네트워크 폭포를 쉽게 만들 수 있습니다.
> - Effect 안에서 직접 가져오는 것은 일반적으로 데이터를 미리 로드하거나 캐시하지 않음을 의미합니다.
> - 그리 편하지 않습니다.
>
> 다음 접근방식을 권장합니다.
>
> - 프레임워크를 사용하는 경우 해당 프레임워크의 내장 데이터 페칭 매커니즘을 사용하세요
> - 클라이언트 측 캐시를 사용하거나 구축하는 것을 고려하세요(ReactQuery, useSWR, ReactRouter6.4+)

#### 분석 보내기(분석 이벤트 로그 발송?)

- 분석 로그는 두번 발송돼도 사용자가 볼 수 있는 동작 차이가 없기 때문에 무시해도 좋다.
- 디버깅을 위해서 스테이징 환경에 배포하거나, Strict Mode를 일시적으로 사용중지 하여 개발 환경 전용의 재마운팅 검사를 수행할 수 있습니다.
- Effect 대신 이벤트 핸들러에서 분석을 보낼 수도 있다.
- 더 정밀한 분석을 위해 Intersection Observer를 사용해 어떤 컴포넌트가 뷰포트에 있는지와 얼마나 오래 보이는지 추적하는데 도움이 될 수 있습니다.

### Effect가 아닌경우: 애플리케이션 초기화

- 일부 로직은 애플리케이션 시작 시에 한번만 실행되어야 합니다. 이러한 로직은 컴포넌트 외부에 배치할 수 있습니다.

```ts
if (typeof window !== "undefined") {
  // 브라우저에서 실행 중인지 확인합니다.
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

- 컴포넌트 외부에서 로직을 실행하면 한번만 실행됨이 보장됩니다. (useCallback 대신 컴포넌트 외부에 함수를 선언한적은 있지만 로직을 선언 해본적은 없는데. 실제로 저렇게 쓸 일이 있을까?)

### Effect가 아닌경우: 제품 구입하기

- 유저의 액션에 의해 실행되어야 하는 로직에 경우 Effect의 로직을 이벤트 핸들러로 이동한다.

### 위에서 설명한 모든 것들을 적용해보기

- React는 항상 이전 렌더의 Effect를 다음 렌더의 Effect 보다 먼저 정리합니다. ( 실행보다 클린업이 먼저 실행된다. )
- Effect는 해당 렌더의 state 값을 캡처 합니다. 이 작동 방식은 클로저입니다.

> 각각의 렌더링은 각각의 고유한 Effect를 갖습니다.
>
> ### 초기 렌더링
>
> - Effect 또한 렌더링 결과물의 일부입니다.
>
> ### 같은 의존성 사이에서의 재렌더링
>
> - 모든 의존성이 동일한 경우 React는 다음 랜더링에서의 Effect를 무시합니다.
>
> ### 다른 의존성으로 재렌더링
>
> - React는 다음 렌더링의 Effect를 적용하기 전에 현재 랜더링의 실행된 Effect를 정리합니다.
>
> ### 언마운트
>
> - React는 언마운트 시에도 Effect의 클린업함수를 실행합니다.
>
> ### 개발 환경에서만 동작
>
> - Strict Mode가 활셩화 된 경우 React는 모든 컴포넌트를 한 번 마운트한 후에 다시 마운트 합니다.
> - 이는 클린업이 필요한 Effect를 찾는데 도움이 되며 경쟁조건과 같은 버그를 초기에 드러날 수 있게 합니다.
> - 파일을 저장할 때마다 Effect를 다시 마운트 합니다.
